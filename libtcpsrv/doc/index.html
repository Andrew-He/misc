<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>libtcpsrv</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


@media screen {
  body {
    max-width: 50em; /* approximately 80 characters wide */
    margin-left: 16em;
  }

  #toc {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 13em;
    padding: 0.5em;
    padding-bottom: 1.5em;
    margin: 0;
    overflow: auto;
    border-right: 3px solid #f8f8f8;
    background-color: white;
  }

  #toc .toclevel1 {
    margin-top: 0.5em;
  }

  #toc .toclevel2 {
    margin-top: 0.25em;
    display: list-item;
    color: #aaaaaa;
  }

  #toctitle {
    margin-top: 0.5em;
  }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>libtcpsrv</h1>
<span id="author">Troy D. Hanson</span><br />
<span id="email"><code>&lt;<a href="mailto:tdh@tkhanson.net">tdh@tkhanson.net</a>&gt;</code></span><br />
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Back to the <a href="https://github.com/troydhanson/libtcpsrv">libtcpsrv Github page</a>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
libtcpsrv
</dt>
<dd>
<p>
  a callback-driven library that sets up and operates a TCP/IPv6 server, and
  has a built in, extendable, shell-like administrative control port
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_libtcpsrv_a_tcp_ipv6_server">libtcpsrv: a TCP/IPv6 server</h2>
<div class="sectionbody">
<div class="paragraph"><p>This is a Linux library that implements a TCP/IPv6 server. To use this library
an application initializes it, then hands control over to the library for the
lifetime of the server. All the application logic to drive I/O, any periodic
background work and application-defined control port commands are callbacks.</p></div>
<div class="listingblock">
<div class="title">Trivial sink server</div>
<div class="content">
<pre><code>#include "libtcpsrv.h"

tcpsrv_init_t parms = {
  .nthread=2,
  .maxfd = 13,
  .port = 1099,
};

int main() {
  void *t;

  t=tcpsrv_init(&amp;parms);
  tcpsrv_run(t);
  tcpsrv_fini(t);
}</code></pre>
</div></div>
<div class="paragraph"><p>The program above listens on TCP port 1099. It accepts new client connections,
drains any input they send, closes the socket after EOF, rejects new clients if
file descriptors through 13 are all in use, and uses two threads to service the
clients. (Note that IPv4 clients can generally connect to it too; the kernel
normally maps IPv4 addresses into IPv6 space for this kind of server). If it
receives a signal such as SIGINT (Ctrl-C) or SIGTERM it shuts down cleanly.</p></div>
<div class="sect2">
<h3 id="_control_port">Control port</h3>
<div class="paragraph"><p>The optional embedded administrative control port is enabled by adding a single
line to the <code>tcpsrv_init_t</code> parms:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>.cp_path = "/tmp/test.socket",</code></pre>
</div></div>
<div class="paragraph"><p>The path can be any filesystem path where the application has write permission.
The pathname is used to create a UNIX domain socket. Libtcpsrv includes a client
that can connect to it similar to a shell.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>% controlsh -s /tmp/test.socket
Connected to /tmp/test.socket.
[controlsh] /tmp/test.socket % help
help                 this text
quit                 close session
who                  list connections
halt                 stop server</code></pre>
</div></div>
<div class="paragraph"><p>The control port can be used to interrogate the server or configure it.  The
application can add its own control port commands.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_libtcpsrv">Using libtcpsrv</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_steps">General steps</h3>
<div class="paragraph"><p>The application must populate a tcpsrv_init_t structure and call these API functions:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>tcpsrv_init_t parms = {
  .port = 1099,
  /* ... */
};</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>t=tcpsrv_init(&amp;parms);
tcpsrv_run(t);
tcpsrv_fini(t);</code></pre>
</div></div>
<div class="paragraph"><p>Note that tcpsrv_run gives control to the library to run the server indefinitely.</p></div>
<div class="sect3">
<h4 id="_tcpsrv_init">tcpsrv_init</h4>
<div class="paragraph"><p>Call this with the initialization parameters as shown above. It returns an opaque
void* which is used with the remaining tcpsrv API documented below. If the return
pointer is NULL the initialization failed.</p></div>
</div>
<div class="sect3">
<h4 id="_tcpsrv_run">tcpsrv_run</h4>
<div class="paragraph"><p>This is the primary API function. It puts the server into operational state by
listening on the port and operating the callbacks in response to events. It runs
indefinitely. It returns only when the server shuts down in response to a signal
or a shutdown initiated in the control port or in a callback.</p></div>
</div>
<div class="sect3">
<h4 id="_tcpsrv_fini">tcpsrv_fini</h4>
<div class="paragraph"><p>This is called at program termination to release all the internal resources.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_preliminaries">Preliminaries</h3>
<div class="sect3">
<h4 id="tcpsrv_client_t">Connection info</h4>
<div class="paragraph"><p>The callbacks for connection I/O have access to the tcpsrv_client_t structure.
This structure contains the details of the remote peer, and other information:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>int thread_idx;                     /* thread servicing this client */
int fd;                             /* file descriptor to client */
void *slot;                         /* connection slot for client */
struct sockaddr_in6 sa;             /* client address and port  */
char ip_str[INET6_ADDRSTRLEN];      /* client address as string */
int port;                           /* client port (host order) */
time_t accept_ts;                   /* time of socket acceptance */</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_connection_slot">Connection slot</h4>
<div class="paragraph"><p>An application can keep state for each connection in the connection slot.  For
example, to track bytes sent and received on each connection, an application could
define a data structure like this:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>struct slot {
  int bytes_in;
  int bytes_out;
}</code></pre>
</div></div>
<div class="paragraph"><p>Libtcpsrv only needs the size of the data structure being stored in the slot.
The application puts the slot size into the tcpsrv_init_t structure:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>.slot_sz = sizeof(struct slot)</code></pre>
</div></div>
<div class="paragraph"><p>Libtcpsrv then associates a buffer of this size with each connection.  (The
slot_sz may be 0 if not needed).  A pair of callbacks exist so the application
can initialize the slots at program startup, and clean them up at exit.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>.slot_init = setup_slots
.slot_fini = cleanup_slots</code></pre>
</div></div>
<div class="paragraph"><p>Whenever an I/O callback is invoked, the callback has access to the slot
pointer inside the <a href="#tcpsrv_client_t">tcpsrv_client_t</a> argument.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>void on_data(tcpsrv_client_t *c, void *data, int *flags) {
    struct slot *s= (struct slot*)c-&gt;slot;
    ...
}</code></pre>
</div></div>
<div class="paragraph"><p>Slots are allocated at program startup.  Each slot is permanently associated
with one fixed file descriptor.  Just as file descriptors are reused through
the lifetime of the server, so are the slots.  So the application must clear
the slot when a new connection is accepted, in the on_accept callback. It
can then update the slot in the on_data callback. It can do any final work
on the slot in the on_close callback.</p></div>
</div>
<div class="sect3">
<h4 id="_opaque_data_pointer">Opaque data pointer</h4>
<div class="paragraph"><p>The application can pass an opaque data pointer into the tcpsrv_init_t.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>tcpsrv_init_t parms = { .data = opaque_data, /* ... */ };</code></pre>
</div></div>
<div class="paragraph"><p>This data pointer is passed back to the application callbacks. It may be NULL.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_initialization">Initialization</h3>
<div class="paragraph"><p>Initialization parameters reside in tcpsrv_init_t. The application declares one
of these structures, populates the members of interest, and passes it to
tcpsrv_init.  The port is the only required parameter of tcpsrv_init_t.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>tcpsrv_init_t parms = { .port = 1099, /* ... */ };</code></pre>
</div></div>
<div class="paragraph"><p>The configurable parameters in this structure follows.</p></div>
<div class="tableblock">
<table rules="none"
width="90%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Parameters</caption>
<col width="20%" />
<col width="10%" />
<col width="60%" />
<col width="10%" />
<thead>
<tr>
<th align="left" valign="top">member           </th>
<th align="left" valign="top"> type</th>
<th align="left" valign="top"> description                                    </th>
<th align="left" valign="top"> default</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>port</code></p></td>
<td align="left" valign="top"><p class="table"><code>int</code></p></td>
<td align="left" valign="top"><p class="table">TCP port to listen on</p></td>
<td align="left" valign="top"><p class="table"><code></code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>verbose</code></p></td>
<td align="left" valign="top"><p class="table"><code>int</code></p></td>
<td align="left" valign="top"><p class="table">0 (minimal) - higher (more verbose)</p></td>
<td align="left" valign="top"><p class="table"><code>0</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nthread</code></p></td>
<td align="left" valign="top"><p class="table"><code>int</code></p></td>
<td align="left" valign="top"><p class="table">how many worker threads to create</p></td>
<td align="left" valign="top"><p class="table"><code>1</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>slot_sz</code></p></td>
<td align="left" valign="top"><p class="table"><code>int</code></p></td>
<td align="left" valign="top"><p class="table">size of slot structure</p></td>
<td align="left" valign="top"><p class="table"><code>0</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>data</code></p></td>
<td align="left" valign="top"><p class="table"><code>void*</code></p></td>
<td align="left" valign="top"><p class="table">opaque data pointer</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>maxfd</code></p></td>
<td align="left" valign="top"><p class="table"><code>int</code></p></td>
<td align="left" valign="top"><p class="table">max file descriptor number to accept</p></td>
<td align="left" valign="top"><p class="table"><code>100</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>periodic_seconds</code></p></td>
<td align="left" valign="top"><p class="table"><code>int</code></p></td>
<td align="left" valign="top"><p class="table">time interval for periodic callback (0=disable)</p></td>
<td align="left" valign="top"><p class="table"><code>0</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>cp_path</code></p></td>
<td align="left" valign="top"><p class="table"><code>char*</code></p></td>
<td align="left" valign="top"><p class="table">control port pathname (unix domain socket)</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The structure also contains callback function pointers as described below.</p></div>
<div class="sect3">
<h4 id="_callbacks">Callbacks</h4>
<div class="paragraph"><p>These are the callback function pointers in tcpsrv_init_t.</p></div>
<div class="tableblock">
<table rules="none"
width="90%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Callbacks</caption>
<col width="20%" />
<col width="70%" />
<col width="10%" />
<thead>
<tr>
<th align="left" valign="top">callback   </th>
<th align="left" valign="top"> description                                    </th>
<th align="left" valign="top"> default</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>slot_init</code></p></td>
<td align="left" valign="top"><p class="table">callback for slot init at program start up</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>slot_fini</code></p></td>
<td align="left" valign="top"><p class="table">callback for slot clean up at program exit</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>periodic</code></p></td>
<td align="left" valign="top"><p class="table">callback for periodic background work</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>on_accept</code></p></td>
<td align="left" valign="top"><p class="table">callback for initial I/O on new connection</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>on_data</code></p></td>
<td align="left" valign="top"><p class="table">callback for regular I/O on a connection</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>on_close</code></p></td>
<td align="left" valign="top"><p class="table">callback for final work preceding closure</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>on_invoke</code></p></td>
<td align="left" valign="top"><p class="table">callback for control port special purpose</p></td>
<td align="left" valign="top"><p class="table"><code>NULL</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The prototype of each callback is shown below along with a description.</p></div>
<div class="literalblock">
<div class="title">slot_init</div>
<div class="content">
<pre><code>void (*slot_init)(void *slot, int nslots, void *data);</code></pre>
</div></div>
<div class="paragraph"><p>The callback is run once at program startup to initialize the slots. The
library has already allocated the contiguous buffer of slots. This callback
sets up the initial slot contents. The callback gets a pointer to the first
slot, and the number of slots (which is the same as maxfd+1). The callback
should initialize all of the slots before returning. If NULL, the library
zeroes the slots. (Called in the main thread).</p></div>
<div class="literalblock">
<div class="title">slot_fini</div>
<div class="content">
<pre><code>void (*slot_fini)(void *slot, int nslots, void *data);</code></pre>
</div></div>
<div class="paragraph"><p>The callback is run once at program shutdown to clean up the slots. The
callback gets a pointer to the first slot, and the number of slots (which is
the same as maxfd+1). It should do any internal clean up or deep free on the
slots before returning. If NULL, no clean up is performed.  Do not free the
slots- the library does that.  (Called in the main thread).</p></div>
<div class="literalblock">
<div class="title">periodic</div>
<div class="content">
<pre><code>int  (*periodic)(int uptime, void *data);</code></pre>
</div></div>
<div class="paragraph"><p>This callback is invoked every so many seconds for the application to do
"background work".  The number of seconds between invocations is set by the
periodic_seconds parameter. The callback should return 0 normally. It can
return -1 to initiate shutdown of the server- causeing tcpsrv_run to return
in the main function shortly thereafter.  (Called in the main thread).</p></div>
<div class="literalblock">
<div class="title">on_accept</div>
<div class="content">
<pre><code>void (*on_accept)(tcpsrv_client_t *client, void *data, int *flags);</code></pre>
</div></div>
<div class="paragraph"><p>Invoked when a new connection is accepted. Typical things the callback may do:
renew (reset) the slot to clear its old contents (from the previous connection
that used this file descriptor); send initial output to the client; approve the
remote peer address. The client address as well as the file descriptor and
additional information are in the <a href="#tcpsrv_client_t">tcpsrv_client_t</a> structure.</p></div>
<div class="paragraph"><p>The flags argument is a bitmask. The on_accept callback can set these flags in it:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>TCPSRV_DO_CLOSE   /* tell the library to close the connection */
TCPSRV_DO_EXIT    /* tell the library to initiate shut down  */</code></pre>
</div></div>
<div class="paragraph"><p>For example to reject a new connection (e.g., suppose its address is disallowed)
the on_accept callback would do</p></div>
<div class="literalblock">
<div class="content">
<pre><code>*flags |= TCPSRV_DO_CLOSE;</code></pre>
</div></div>
<div class="paragraph"><p>(Called in the main thread).</p></div>
<div class="literalblock">
<div class="title">on_data</div>
<div class="content">
<pre><code>void (*on_data)(tcpsrv_client_t *client, void *data, int *flags);</code></pre>
</div></div>
<div class="paragraph"><p>This is the regular I/O callback. It is normally called when there is input
ready to read on this connection. If NULL, the server uses a default "drain"
callback that discards any input from the client.  The client address as well
as the file descriptor and additional information are in the
<a href="#tcpsrv_client_t">tcpsrv_client_t</a> structure.</p></div>
<div class="paragraph"><p>By default the I/O-ready condition for each connection is "readable" meaning
that the callback is invoked when data is available to read. The application
can confirm that this flag is set like this:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>if (*flags &amp; TCPSRV_CAN_READ) { ... }</code></pre>
</div></div>
<div class="paragraph"><p>If the callback needs to write out a long buffer to the client, and wishes
to poll writability (and readability), it can modify the flags like this:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>*flags |= (TCPSRV_POLL_WRITE | TCPSRV_POLL_READ);</code></pre>
</div></div>
<div class="paragraph"><p>Now when the callback is invoked it can test for the writable condition:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>if (*flags &amp; TCPSRV_CAN_WRITE) { ... }</code></pre>
</div></div>
<div class="paragraph"><p>After the write completes it can reset the polling condition to readable:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>*flags |= TCPSRV_POLL_READ;</code></pre>
</div></div>
<div class="paragraph"><p>In other words, setting TCPSRV_POLL_READ and/or TCPSRV_POLL_WRITE in the flags
causes those polling on those conditions; setting neither flag causes the
existing polling condition to be retained.</p></div>
<div class="paragraph"><p>The callback can also set these flags before returning:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>TCPSRV_DO_CLOSE   /* tell the library to close the connection */
TCPSRV_DO_EXIT    /* tell the library to initiate shut down  */</code></pre>
</div></div>
<div class="paragraph"><p>(Called in the worker thread).</p></div>
<div class="literalblock">
<div class="title">on_close</div>
<div class="content">
<pre><code>void (*on_close)(tcpsrv_client_t *client, void *data);</code></pre>
</div></div>
<div class="paragraph"><p>The library invokes the on_close callback immediately before closing a
connection. This is the last chance the application has to do anything with the
client before closure. It can also clean up the slot (or that can be done in
the on_accept callback). Note that the on_data callback initiates closure
of the connection (by setting TCPSRV_DO_CLOSE in the flags); this callback
runs afterward, immediately prior to the library performing the actual close.
The client address as well as the file descriptor and additional information
are in the <a href="#tcpsrv_client_t">tcpsrv_client_t</a> structure.</p></div>
<div class="paragraph"><p>(Called in the worker thread).</p></div>
<div class="literalblock">
<div class="title">on_invoke</div>
<div class="content">
<pre><code>void (*on_invoke)(tcpsrv_client_t *client, void *ptr, void *data, int *flags);</code></pre>
</div></div>
<div class="paragraph"><p>This special-purpose callback is invoked when a control port command callback
uses tcpsrv_invoke. The on_invoke callback gets executed in each worker thread
on each active slot. It is a mechanism for the control port thread (the main
thread) to pass information to, or gather information from, the worker threads.
Further information is described in the control port documentation.
The client address as well as the file descriptor and additional information
are in the <a href="#tcpsrv_client_t">tcpsrv_client_t</a> structure.</p></div>
<div class="paragraph"><p>The callback can also set these flags before returning:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>TCPSRV_DO_CLOSE   /* tell the library to close the connection */
TCPSRV_DO_EXIT    /* tell the library to initiate shut down  */</code></pre>
</div></div>
<div class="paragraph"><p>(Called in the worker thread).</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_control_port_2">Control port</h3>
<div class="paragraph"><p>The embedded administrative control port is an optional feature enabled by
setting the cp_path member before initializing the library. When the control
port is enabled, the administrator can connect to the running libtcpsrv server
using the included controlsh utility, giving the cp_path pathname to it:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>% controlsh -s /tmp/test.socket</code></pre>
</div></div>
<div class="paragraph"><p>The embedded control port has a few built-in commands such as "help", "halt"
and "who". These display the list of commands, shut down the server and show
the list of connections, respectively.  The application can add its own
commands to manipulate or query application state.  A control port command has
a name, a callback, and a longer descriptive string.  To add a control port
command, use cp_add_cmd (after tcpsrv_init and before tcpsrv_run):</p></div>
<div class="literalblock">
<div class="content">
<pre><code>t=tcpsrv_init(&amp;parms);
cp_add_cmd(parms.cp, "status", status_cmd, "get status", NULL);
tcpsrv_run(t);</code></pre>
</div></div>
<div class="sect3">
<h4 id="_cp_add_cmd">cp_add_cmd</h4>
<div class="paragraph"><p>This function has the following prototype:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>void cp_add_cmd(void*cp, char *name, cp_cmd_f *cmd, char *help, void *data);</code></pre>
</div></div>
<div class="paragraph"><p>The initial parameter must be the cp member of the tcpsrv_init_t (after
tcpsrv_init has returned successfully). The name is the command name, and the
help is a longer string of help text which may be NULL. The final data pointer
is an opaque data type that is passed to the command callback. The cmd argument is
the function pointer of the command callback described next.</p></div>
<div class="sect4">
<h5 id="_commmand_callback">Commmand callback</h5>
<div class="paragraph"><p>The command callback is a function pointer which must have this prototype:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>int (*cp_cmd_f)(void *cp, int argc, char **argv, void *data);</code></pre>
</div></div>
<div class="paragraph"><p>It&#8217;s initial argument, cp, is an opaque type used to send reply text to
the control port via cp_printf as shown below. The next two arguments argc and
argv are analogous to the arguments to the main function in C. They indicate
the command name being run and its arguments. The data pointer is the opaque
type that was passed into cp_add_cmd.</p></div>
<div class="paragraph"><p>The callback can use cp_printf to return data to the control port. E.g.,</p></div>
<div class="literalblock">
<div class="content">
<pre><code>cp_printf(cp, "%s: received %d arguments", argv[0], argc);</code></pre>
</div></div>
<div class="paragraph"><p>The callback can also call a few special libtcpsrv API: tcpsrv_shutdown(void *)
initiates the shutdown of the server. It must take as its argument the opaque
pointer that tcpsrv_init returned. (This means that you must pass that pointer
as the data pointer of cp_add_cmd, or pass it inside data in your own structure).
The other special API that the callback can make use of is tcpsrv_invoke which
is described separately.</p></div>
<div class="paragraph"><p>This callback must return CP_OK normally, or CP_CLOSE to cause libtcpsrv to
disconnect the control port client.</p></div>
<div class="paragraph"><div class="title">tcpsrv_invoke</div><p>This special API call can be used to build sophisticated control port command
callbacks that interact with the worker threads to produce the control port
output.  When a control port command callback invokes tcpsrv_invoke(void <strong>,
void</strong>) the first argument must be the opaque type returned from tcpsrv_init.
The second pointer is arbitrary but may be used to facilitate information
exchange with the worker threads.</p></div>
<div class="paragraph"><p>When this function is called, the control port command callback in the main
thread causes each worker thread to invoke the on_invoke callback (defined
in tcpsrv_init_t) on each active connection slot. Therefore the on_invoke
callback works in concert with the control port command. (For example the
control port command callback can create a pipe for each thread, pass the
address of the pipe array as the second argument to tcpsrv_invoke, and have
the on_invoke callback write back on those pipes from each worker thread).</p></div>
<div class="paragraph"><p>TODO: example.</p></div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_internals">Internals</h2>
<div class="sectionbody">
<div class="paragraph"><p>Libtcpsrv establishes the listening socket, then uses epoll in its main thread
to wait for new connections. (This epoll also handles signals to the server,
including periodic background timers, and control port I/O). When a new client
connection occurs, the accept callback (if one is defined), gets run in the
server&#8217;s main thread. Afterward, the new connection gets permanently assigned
to a worker thread where all further I/O and eventual closure occurs.</p></div>
<div class="paragraph"><p>The server keeps a pipe to each worker thread. The main thread periodically
places requests into a worker&#8217;s pipe, which the worker reads and acts on. This
is used to implement clean shutdown and other custodial signaling to threads.</p></div>
<div class="paragraph"><p>The server keeps a structure, tcpsrv_slotinfo_t, for each client connection. It
is initialized when the connection is accepted. It contains a tcpsrv_client_t
structure, which is exposed to the application callbacks. It contains everything
the application may want to know about the remote client. This includes its
IPv6 address, its TCP source port, the timestamp of its acceptance and the file
descriptor. It also contains a pointer to the application defined data slot.</p></div>
<div class="paragraph"><p>When input arrives from an established client, the worker thread which services
that file descriptor gets notified via its epoll. (Each worker thread has its
own epoll to get notified of client I/O or messaging from the main thread). The
worker thread handles client I/O by invoking the application on_data callback.
That callback can read and write to the file descriptor, and update any state
it keeps in the application slot for that descriptor. When the application
is ready to close the descriptor, it must modify the session flags to set the
TCPSRV_DO_CLOSE bit. The worker thread sees this bit, runs the on_close
callback and then closes the descriptor. It is critical that the flag be used
to tell the worker thread to close the descriptor, rather than closing it
inside the on_data callback. This allows the worker thread to clean up the
data structures; it also prevents the descriptor from being instantly reused
in the main thread (when a new session is accepted) prior to this clean up.</p></div>
<div class="paragraph"><p>The eventual termination of the server application can be initiated by receipt
of a signal such as SIGTERM or SIGINT, or through other means including a
shutdown initiation inside the I/O callbacks or control port commands. At that
point tcpsrv_run returns, the application calls tcpsrv_fini and exits.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-01-18 22:07:28 EST
</div>
</div>
</body>
</html>
