libtcpsrv
=========
Troy D. Hanson <tdh@tkhanson.net>

Back to the https://github.com/troydhanson/libtcpsrv[libtcpsrv Github page].

libtcpsrv::
  a library that sets up and operates a TCP/IPv6 server, driven by callbacks
  into the application, also having a shell-like administrative control port 

libtcpsrv: a TCP/IPv6 server
----------------------------
This is a Linux library that implements a TCP/IPv6 server. To use this library
an application initializes it, then hands control over to the library for the
lifetime of the server. Application code resides in callbacks for I/O, periodic
background work and custom control port commands.

.Trivial sink server
---------------------------------------------------------------------------
#include "libtcpsrv.h"

tcpsrv_init_t parms = {
  .nthread=2,
  .maxfd = 13,
  .port = 1099,
};

int main() {
  void *t;

  t=tcpsrv_init(&parms);
  tcpsrv_run(t);
  tcpsrv_fini(t);
}
---------------------------------------------------------------------------

The program above listens on TCP port 1099. It accepts new client connections,
drains any input they send, closes the socket after EOF, rejects new clients if
file descriptors through 13 are all in use, and uses two threads to service the
clients. (Note that IPv4 clients can generally connect to it too; the kernel
normally maps IPv4 clients into IPv6 space). If it receives a signal such as
SIGINT (Ctrl-C) or SIGTERM it shuts down cleanly. All callbacks can be NULL.

Control port
~~~~~~~~~~~~
The control port is enabled by setting a single member in the `tcpsrv_init_t`:

  .cp_path = "/tmp/test.socket",

The path can be any filesystem path where the application has write permission.
The pathname is used to create a UNIX domain socket. Libtcpsrv includes a client
that can connect to it similar to a shell.

  % controlsh -s /tmp/test.socket
  Connected to /tmp/test.socket.
  [controlsh] /tmp/test.socket % help
  help                 this text
  quit                 close session
  who                  list connections
  halt                 stop server

The control port can be used to interrogate the server or configure it.  The
application can add its own control port commands.

Using libtcpsrv
---------------

General steps
~~~~~~~~~~~~~
The application must populate a tcpsrv_init_t structure and call these API functions:

  tcpsrv_init_t parms = { .port = 1099, /* ... */ };

  void *t=tcpsrv_init(&parms); 
  if (t == NULL) exit(-1);

  tcpsrv_run(t);
  tcpsrv_fini(t);

Note that tcpsrv_run gives control to the library to run the server indefinitely.

tcpsrv_init
^^^^^^^^^^^
Call this with the initialization parameters as shown above. It returns an opaque
void* which is used with the remaining tcpsrv API documented below. If the return
pointer is NULL the initialization failed.

tcpsrv_run
^^^^^^^^^^^
This is the primary API function. It puts the server into operational state by 
listening on the port and operating the callbacks in response to events. It runs
indefinitely. It returns only when the server shuts down in response to a signal
or a shutdown initiated in the control port or in a callback.

tcpsrv_fini
^^^^^^^^^^^
This is called at program termination to release all the internal resources.

Preliminaries
~~~~~~~~~~~~~

[[tcpsrv_client_t]]
Connection info
^^^^^^^^^^^^^^^
The callbacks for connection I/O have access to the tcpsrv_client_t structure.
This structure contains the details of the remote peer, and other information:

  int thread_idx;                     /* thread servicing this client */
  int fd;                             /* file descriptor to client */
  void *slot;                         /* connection slot for client */
  struct sockaddr_in6 sa;             /* client address and port  */
  char ip_str[INET6_ADDRSTRLEN];      /* client address as string */
  int port;                           /* client port (host order) */
  time_t accept_ts;                   /* time of socket acceptance */

Connection slot
^^^^^^^^^^^^^^^
The application can keep its own per-connection state in the connection slot.
For example, an application could define a data structure like this:

  struct slot {
    int bytes_in;
    int bytes_out;
  }

Libtcpsrv only needs the size of the data structure being stored in the slot.
The size goes into the tcpsrv_init_t structure:

  .slot_sz = sizeof(struct slot)

Libtcpsrv then associates a buffer of this size with each connection.  Use of
slots is optional- the slot_sz may be 0 if not needed.  The application may
set two callbacks to initialize the slots at startup (otherwise they are simply
zeroed by default), and clean them up at exit. 

  .slot_init = setup_slots
  .slot_fini = cleanup_slots

At runtime, the I/O callbacks reach the slot through the
<<tcpsrv_client_t,tcpsrv_client_t>> pointer. 

  void on_data(tcpsrv_client_t *c, void *data, int *flags) {
      struct slot *s= (struct slot*)c->slot;
  }

Slots are allocated at startup, and associated with one fixed file descriptor.
Just as file descriptors are reused through the lifetime of the server, so are
the slots.  So the application must clear the slot when a new connection is
accepted, in the on_accept callback. It can then update the slot in the on_data
callback. It can do any final work on the slot in the on_close callback.

Opaque data pointer
^^^^^^^^^^^^^^^^^^^
The application can pass its own opaque data pointer into the tcpsrv_init_t.

  tcpsrv_init_t parms = { .data = opaque_data, /* ... */ };

An application can create its own data structure and store its pointer in data.
This data pointer is passed back to the application callbacks. It may be NULL.
If the application stores a structure pointer in data, it should include a lock
if callbacks need to update it.

Initialization
~~~~~~~~~~~~~~
Initialization parameters reside in tcpsrv_init_t. The application populates
the members of interest, and passes it to tcpsrv_init.  It holds the basic 
configuration parameters, and the callback pointers. Only the port is required.

  tcpsrv_init_t parms = { .port = 1099 };

.Parameters
[width="90%",cols="20m,10m,60,10m",grid="none",options="header"]
|===============================================================================
|member           | type| description                                    | default
|port             | int | TCP port to listen on (required)               | 
|verbose          | int | 0 (minimal) - higher (more verbose)            | 0
|nthread          | int | how many worker threads to create              | 1 
|slot_sz          | int | size of slot structure                         | 0
|data             |void*| opaque data pointer                            | NULL
|maxfd            | int | max file descriptor number to accept           | 100
|periodic_seconds | int | time interval for periodic callback (0=disable)| 0
|cp_path          |char*| control port pathname (unix domain socket)     | NULL
|===============================================================================

These are the callback function pointers in tcpsrv_init_t.

.Callbacks
[width="90%",cols="20m,70,10m",grid="none",options="header"]
|===============================================================================
|callback   | description                                    | default
|slot_init  | callback for slot init at program start up     | NULL
|slot_fini  | callback for slot clean up at program exit     | NULL
|periodic   | callback for periodic background work          | NULL
|on_accept  | callback for initial I/O on new connection     | NULL
|on_data    | callback for regular I/O on a connection       | NULL
|on_close   | callback for final work preceding closure      | NULL
|on_invoke  | callback for control port special purpose      | NULL
|===============================================================================

The prototype of each callback is shown below along with a description.

.slot_init

  void (*slot_init)(void *slot, int nslots, void *data);

The callback is run once at program startup to initialize the connection slots.
The library allocates the slots (in a contiguous buffer), then this callback
initializes the slot contents. The callback gets a pointer to the first slot,
and the number of slots (which is the same as maxfd+1). The callback should
initialize all of the slots before returning. If NULL, the library zeroes the
slots. (Called in the main thread).

.slot_fini

  void (*slot_fini)(void *slot, int nslots, void *data);

The callback is run once at program shutdown to clean up the slots. The
callback gets a pointer to the first slot, and the number of slots (which is
the same as maxfd+1). It should do any internal clean up or deep free on the
slots before returning. It may be NULL if no clean up is needed. Do not free
the slot pointer- the library does that.  (Called in the main thread).

.periodic

  int  (*periodic)(int uptime, void *data);

This callback is invoked every so many seconds for the application to do
"background work".  The number of seconds between invocations is set by the
periodic_seconds parameter. The callback should return 0 normally. It can
return -1 to initiate shutdown of the server (causing tcpsrv_run to return
in the main function shortly thereafter).  The uptime parameter is the number
of seconds the server has been running. (Called in the main thread).

.on_accept

  void (*on_accept)(tcpsrv_client_t *client, void *data, int *flags);

Invoked when a new connection is accepted. Typical things the callback may do:
renew (reset) the slot to clear its old contents (from the previous connection
that used this file descriptor); send initial output to the client; validate the
client address is allowed. The client address as well as the file descriptor and
additional information are in the <<tcpsrv_client_t,tcpsrv_client_t>> structure.

For example to send initial output to a client, the callback can:

  write(client->fd, "hello\n", 6);

The flags argument is a bitmask. The on_accept callback can set these flags in it:

  TCPSRV_DO_CLOSE   /* tell the library to close the connection */
  TCPSRV_DO_EXIT    /* tell the library to initiate shut down  */

For example to reject a new connection (e.g., suppose its address is disallowed)
the on_accept callback would do

  *flags |= TCPSRV_DO_CLOSE;

To print the connection's remote address, you can use the preformatted ip_str:

   syslog(LOG_INFO|LOG_USER, "new connection from %s", client->ip_str);

This callback may be NULL. (Called in the worker thread).

.on_data
  void (*on_data)(tcpsrv_client_t *client, void *data, int *flags);

Input from the client triggers the on_data callback.  The client address, file
descriptor, and more are in the <<tcpsrv_client_t,tcpsrv_client_t>> structure.
It can read from the client, write to the client, update the slot, or modify
the flags to change the polling condition or initiate connection closure, e.g.: 

  *flags |= TCPSRV_DO_CLOSE;

Do not close the descriptor in the callback- instead use the flags as shown 
to tell the library to close it. 

The file descriptor is in blocking mode. The polling condition is, by default,
readability. You can safely do one read in this callback without blocking. If
more data remains readable on the connection, the on_data callback gets invoked
again. (The callback is "level triggered"). Alternatively the callback can consume 
all available input using recv with MSG_DONTWAIT until EWOULDBLOCK/EAGAIN occurs.

If the callback writes data to the client and receives a return code indicating
a partial write occurred, the callback must save the unwritten part of the data
and finish the write later. (The slot can be used to set up a buffer for this).
In order to finish the write later, the callback can change the poll condition
so that writability (in addition to readability) triggers the on_data callback.

  *flags |= (TCPSRV_POLL_WRITE | TCPSRV_POLL_READ);

Now when the callback is invoked it can test for the writable condition:

  if (*flags & TCPSRV_CAN_WRITE) { ... }

After the write completes it can reset the polling condition to readable:

  *flags |= TCPSRV_POLL_READ;

In other words, setting TCPSRV_POLL_READ and/or TCPSRV_POLL_WRITE changes the
poll condition to only the given flags; setting neither flag causes the
existing polling condition to be retained. The flags always have either or both
of TCPSRV_CAN_READ or TCPSRV_CAN_WRITE set when the callback runs.  But
TCPSRV_CAN_WRITE is only set if you have modified the poll condition to
explicitly poll for writability. (Called in the worker thread).

.on_close
  void (*on_close)(tcpsrv_client_t *client, void *data);

This callback is invoked immediately before the library closes a connection.
This is the last chance the application has to do anything with the client.
It can also clean up the slot (or that can be done in the on_accept callback).
The on_data callback initiates connection closure by setting TCPSRV_DO_CLOSE in
the flags; this callback runs afterward.  The client address, file descriptor,
and more are in the <<tcpsrv_client_t,tcpsrv_client_t>> structure.  (Called in
the worker thread).

.on_invoke
  void (*on_invoke)(tcpsrv_client_t *client, void *ptr, void *data, int *flags);

This callback is invoked when a control port command uses tcpsrv_invoke. The
on_invoke callback gets executed in each worker thread on each active slot. It
then gets called one final time with TCPSRV_OP_COMPLETE set in the flags mask.
This callback is a mechanism for the control port thread (the main thread) to
pass information to, or gather information from, the worker threads.  Further
information is described in the control port section.  The client address, 
file descriptor, and more are in the <<tcpsrv_client_t,tcpsrv_client_t>> structure.
(Called in the worker thread).

The callback can also set these flags before returning:

  TCPSRV_DO_CLOSE   /* tell the library to close the connection */
  TCPSRV_DO_EXIT    /* tell the library to initiate shut down  */

Control port
~~~~~~~~~~~~
The embedded administrative control port is enabled by setting the cp_path
member before initializing the library. When the control port is enabled, the
administrator can connect to the running libtcpsrv server using the included
controlsh utility, giving the cp_path pathname to it:

  % controlsh -s /tmp/test.socket

The embedded control port has a few built-in commands such as "help", "halt"
and "who". These display the list of commands, shut down the server and show
the list of connections, respectively.  The application can add its own
commands to manipulate or query application state.  A control port command has
a name, a callback, and a longer descriptive string.  To add a control port
command, use cp_add_cmd (after tcpsrv_init and before tcpsrv_run):

  t=tcpsrv_init(&parms);
  cp_add_cmd(parms.cp, "status", status_cmd, "get status", NULL);
  tcpsrv_run(t);

cp_add_cmd
^^^^^^^^^^
This function has the following prototype:

  void cp_add_cmd(void*cp, char *name, cp_cmd_f *cmd, char *help, void *data);

The initial parameter must be the cp member of the tcpsrv_init_t (after
tcpsrv_init has returned successfully). The name is the command name, and the
help is a longer string of help text which may be NULL. The final data pointer
is an opaque data type that is passed to the command callback. The cmd argument is
the function pointer of the command callback described next.

Commmand callback
+++++++++++++++++

The command callback is a function pointer which must have this prototype:

  int (*cp_cmd_f)(void *cp, int argc, char **argv, void *data);

It's initial argument, cp, is an opaque type used to send reply text to
the control port via cp_printf as shown below. The next two arguments argc and
argv are analogous to the arguments to the main function in C. They indicate
the command name being run and its arguments. The data pointer is the opaque
type that was passed into cp_add_cmd.

The callback can use cp_printf to return data to the control port. E.g.,

  cp_printf(cp, "%s: received %d arguments", argv[0], argc);

The callback can also call a few special libtcpsrv API: tcpsrv_shutdown(void *)
initiates the shutdown of the server. It must take as its argument the opaque
pointer that tcpsrv_init returned. (This means that you must pass that pointer
as the data pointer of cp_add_cmd, or pass it inside data in your own structure).
The other special API that the callback can make use of is tcpsrv_invoke which
is described separately.

This callback must return CP_OK normally, or CP_CLOSE to cause libtcpsrv to
disconnect the control port client.

.tcpsrv_invoke

This special API call can be used to build sophisticated control port command
callbacks that interact with the worker threads to produce the control port
output.  When a control port command callback invokes tcpsrv_invoke(void *,
void*) the first argument must be the opaque type returned from tcpsrv_init.
The second pointer is arbitrary but may be used to facilitate information
exchange with the worker threads.

When this function is called, the control port command callback in the main
thread causes each worker thread to invoke the on_invoke callback (defined 
in tcpsrv_init_t) on each active connection slot. Therefore the on_invoke
callback works in concert with the control port command. (For example the
control port command callback can create a pipe for each thread, pass the
address of the pipe array as the second argument to tcpsrv_invoke, and have
the on_invoke callback write back on those pipes from each worker thread).

TODO: example.

Internals
---------
Libtcpsrv establishes the listening socket, then uses epoll in its main thread
to wait for new connections. (This epoll also handles signals to the server, 
including periodic background timers, and control port I/O). When a new client
connection occurs, it gets accepted in the main thread. Then the new connection
gets permanently assigned to a worker thread where the accept callback is run,
and where all further I/O and eventual closure occurs.  

The server keeps a pipe to each worker thread. The main thread periodically
places requests into a worker's pipe, which the worker reads and acts on. This
is used to implement clean shutdown and other custodial signaling to threads.

The server keeps a structure, tcpsrv_slotinfo_t, for each client connection. It
is initialized when the connection is accepted. It contains a tcpsrv_client_t 
structure, which is exposed to the application callbacks. It contains everything
the application may want to know about the remote client. This includes its 
IPv6 address, its TCP source port, the timestamp of its acceptance and the file
descriptor. It also contains a pointer to the application defined data slot.

When input arrives from an established client, the worker thread which services
that file descriptor gets notified via its epoll. (Each worker thread has its 
own epoll to get notified of client I/O or messaging from the main thread). The
worker thread handles client I/O by invoking the application on_data callback.
That callback can read and write to the file descriptor, and update any state
it keeps in the application slot for that descriptor. When the application 
is ready to close the descriptor, it must modify the session flags to set the
TCPSRV_DO_CLOSE bit. The worker thread sees this bit, runs the on_close 
callback and then closes the descriptor. It is critical that the flag be used
to tell the worker thread to close the descriptor, rather than closing it 
inside the on_data callback. This allows the worker thread to clean up the
data structures; it also prevents the descriptor from being instantly reused
in the main thread (when a new session is accepted) prior to this clean up.

The eventual termination of the server application can be initiated by receipt
of a signal such as SIGTERM or SIGINT, or through other means including a 
shutdown initiation inside the I/O callbacks or control port commands. At that
point tcpsrv_run returns, the application calls tcpsrv_fini and exits.
